const winston = require("winston");
const { format } = require("winston");
const { Kafka, logLevel, Partitioners } = require("kafkajs");

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL,
  format: format.combine(
    format.timestamp(),
    format.printf((i) => `${i.timestamp} [${i.level}] ${i.message}`),
  ),
  transports: [new winston.transports.Console()],
});

const toWinstonLogLevel = (level) => {
  switch (level) {
    case logLevel.ERROR:
    case logLevel.NOTHING:
      return "error";
    case logLevel.WARN:
      return "warn";
    case logLevel.INFO:
      return "info";
    case logLevel.DEBUG:
      return "debug";
  }
};

const generateLogError = (obj) => {
  let str = "";
  for (let i of Object.keys(obj)) {
    if (!obj[i]) str += `key [${i}] cannot be undefined. `;
  }
  return str;
};
class OperationalTracer {
  constructor() {
    this.domain = process.env["NOMAD_JOB_NAME"];
    this.environment = process.env["ENV"];
    this.addr = process.env["NOMAD_HOST_ADDR_http"] || "";
  }

  async init(config) {
    const { domain, environment } = this;
    if (!domain || !environment) {
      logger.error(generateLogError({ domain, environment }));
      throw new Error("[Operational Tracer] Failing inizialization");
    }
    try {
      logger.info(
        "aea-logger [operational tracer] init - Kafka brokers: " +
          config.brokers,
      );
      logger.info(
        "aea-logger [operational tracer] init - Kafka Producer Connecting...",
      );
      logger.info("   |--> topic: " + config.producer.topic);
      logger.info("   |--> clientId: " + config.clientId);
      this.kafka = new Kafka(config);
      this.topic = config.producer.topic;
      this.producer = this.kafka.producer({
        createPartitioner: Partitioners.LegacyPartitioner,
      });
      await this.producer.connect();
      logger.info("aea-logger [operational tracer] initialized");
    } catch (err) {
      logger.error(`aea-logger [operational tracer] error ${err}`);
    }
  }

  formatMessage(message, level, service) {
    return {
      timestamp: Date.now(),
      traceID: Date.now(),
      type: level,
      service,
      domain: this.domain,
      environment: this.environment,
      instance: this.addr,
      message,
    };
  }

  async tracerSend(message, level, service) {
    if (!this.producer) {
      logger.error(
        `aea-logger [operational tracer] operationalTracer not init`,
      );
      return;
    }
    try {
      const fmtMessage = this.formatMessage(message, level, service);
      await this.producer.send({
        topic: this.topic,
        messages: [{ value: JSON.stringify(fmtMessage) }],
      });
    } catch (err) {
      logger.error(`aea-logger [operational tracer] error ${err}`);
    }
  }

  error(service, message) {
    this.tracerSend(message, toWinstonLogLevel(logLevel.ERROR), service);
  }
  info(service, message) {
    this.tracerSend(message, toWinstonLogLevel(logLevel.INFO), service);
  }
  warning(service, message) {
    this.tracerSend(message, toWinstonLogLevel(logLevel.WARN), service);
  }
  debug(service, message) {
    this.tracerSend(message, toWinstonLogLevel(logLevel.DEBUG), service);
  }
}

const operationalTracer = new OperationalTracer();

module.exports = {
  logger,
  operationalTracer,
};
