"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_json_schema_walker = require("json-schema-walker");

// src/const.ts
var allowedKeywords = [
  "$ref",
  "definitions",
  // From Schema
  "title",
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "enum",
  "type",
  "not",
  "allOf",
  "oneOf",
  "anyOf",
  "items",
  "properties",
  "additionalProperties",
  "description",
  "format",
  "default",
  "nullable",
  "discriminator",
  "readOnly",
  "writeOnly",
  "example",
  "externalDocs",
  "deprecated",
  "xml"
];

// src/index.ts
var InvalidTypeError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidTypeError";
    this.message = message;
  }
};
var oasExtensionPrefix = "x-";
var handleDefinition = async (def, schema) => {
  if (typeof def !== "object") {
    return def;
  }
  const type = def.type;
  if (type) {
    const walker = new import_json_schema_walker.Walker();
    await walker.loadSchema(
      {
        definitions: schema["definitions"] || [],
        ...def,
        $schema: schema["$schema"]
      },
      {
        dereference: true,
        cloneSchema: true,
        dereferenceOptions: {
          dereference: {
            circular: "ignore"
          }
        }
      }
    );
    await walker.walk(convertSchema, walker.vocabularies.DRAFT_07);
    if ("definitions" in walker.rootSchema) {
      delete walker.rootSchema.definitions;
    }
    return walker.rootSchema;
  }
  if (Array.isArray(def)) {
    const typeArr = def;
    const hasNull = typeArr.includes("null");
    if (hasNull) {
      const actualTypes = typeArr.filter((l) => l !== "null");
      return {
        type: actualTypes.length === 1 ? actualTypes[0] : actualTypes,
        nullable: true
        // this is incorrect but thats ok, we are in the inbetween phase here
      };
    }
  }
  return def;
};
var convert = async (schema, options) => {
  const walker = new import_json_schema_walker.Walker();
  const convertDefs = options?.convertUnreferencedDefinitions ?? true;
  await walker.loadSchema(schema, options);
  await walker.walk(convertSchema, walker.vocabularies.DRAFT_07);
  const rootSchema = walker.rootSchema;
  if (convertDefs && rootSchema?.definitions) {
    for (const defName in rootSchema.definitions) {
      const def = rootSchema.definitions[defName];
      rootSchema.definitions[defName] = await handleDefinition(def, schema);
    }
  }
  return rootSchema;
};
function stripIllegalKeywords(schema) {
  if (typeof schema !== "object") {
    return schema;
  }
  delete schema["$schema"];
  delete schema["$id"];
  if ("id" in schema) {
    delete schema["id"];
  }
  return schema;
}
function convertSchema(schema) {
  if (!schema) {
    return schema;
  }
  schema = stripIllegalKeywords(schema);
  schema = convertTypes(schema);
  schema = rewriteConst(schema);
  schema = convertDependencies(schema);
  schema = convertNullable(schema);
  schema = rewriteIfThenElse(schema);
  schema = rewriteExclusiveMinMax(schema);
  schema = convertExamples(schema);
  if (typeof schema["patternProperties"] === "object") {
    schema = convertPatternProperties(schema);
  }
  if (schema.type === "array" && typeof schema.items === "undefined") {
    schema.items = {};
  }
  schema = convertIllegalKeywordsAsExtensions(schema);
  return schema;
}
var validTypes = /* @__PURE__ */ new Set([
  "null",
  "boolean",
  "object",
  "array",
  "number",
  "string",
  "integer"
]);
function validateType(type) {
  if (typeof type === "object" && !Array.isArray(type)) {
    if (type.$ref) {
      return;
    }
    if (type.properties) {
      return;
    }
  }
  const types = Array.isArray(type) ? type : [type];
  types.forEach((type2) => {
    if (type2 && !validTypes.has(type2))
      throw new InvalidTypeError('Type "' + type2 + '" is not a valid type');
  });
}
function convertDependencies(schema) {
  const deps = schema.dependencies;
  if (typeof deps !== "object") {
    return schema;
  }
  delete schema["dependencies"];
  if (!Array.isArray(schema.allOf)) {
    schema.allOf = [];
  }
  for (const key in deps) {
    const foo = {
      oneOf: [
        {
          not: {
            required: [key]
          }
        },
        {
          required: [key, deps[key]].flat()
        }
      ]
    };
    schema.allOf.push(foo);
  }
  return schema;
}
function convertNullable(schema) {
  for (const key of ["oneOf", "anyOf"]) {
    const schemas = schema[key];
    if (!schemas) continue;
    if (!Array.isArray(schemas)) {
      return schema;
    }
    const hasNullable = schemas.some((item) => item.type === "null");
    if (!hasNullable) {
      return schema;
    }
    const filtered = schemas.filter((l) => l.type !== "null");
    for (const schemaEntry of filtered) {
      schemaEntry.nullable = true;
    }
    schema[key] = filtered;
  }
  return schema;
}
function convertTypes(schema) {
  if (typeof schema !== "object") {
    return schema;
  }
  if (schema.type === void 0) {
    return schema;
  }
  validateType(schema.type);
  if (Array.isArray(schema.type)) {
    if (schema.type.includes("null")) {
      schema.nullable = true;
    }
    const typesWithoutNull = schema.type.filter((type) => type !== "null");
    if (typesWithoutNull.length === 0) {
      delete schema.type;
    } else if (typesWithoutNull.length === 1) {
      schema.type = typesWithoutNull[0];
    } else {
      delete schema.type;
      schema.anyOf = typesWithoutNull.map((type) => ({ type }));
    }
  } else if (schema.type === "null") {
    delete schema.type;
    schema.nullable = true;
  }
  return schema;
}
function convertPatternProperties(schema) {
  schema["x-patternProperties"] = schema["patternProperties"];
  delete schema["patternProperties"];
  schema.additionalProperties ?? (schema.additionalProperties = true);
  return schema;
}
function convertIllegalKeywordsAsExtensions(schema) {
  const keys = Object.keys(schema);
  keys.filter(
    (keyword) => !keyword.startsWith(oasExtensionPrefix) && !allowedKeywords.includes(keyword)
  ).forEach((keyword) => {
    const key = `${oasExtensionPrefix}${keyword}`;
    schema[key] = schema[keyword];
    delete schema[keyword];
  });
  return schema;
}
function convertExamples(schema) {
  if (schema["examples"] && Array.isArray(schema["examples"])) {
    schema["example"] = schema["examples"][0];
    delete schema["examples"];
  }
  return schema;
}
function rewriteConst(schema) {
  if (Object.hasOwnProperty.call(schema, "const")) {
    schema.enum = [schema.const];
    delete schema.const;
  }
  return schema;
}
function rewriteIfThenElse(schema) {
  if (typeof schema !== "object") {
    return schema;
  }
  if ("if" in schema && schema.if && schema.then) {
    schema.oneOf = [
      { allOf: [schema.if, schema.then].filter(Boolean) },
      { allOf: [{ not: schema.if }, schema.else].filter(Boolean) }
    ];
    delete schema.if;
    delete schema.then;
    delete schema.else;
  }
  return schema;
}
function rewriteExclusiveMinMax(schema) {
  if (typeof schema.exclusiveMaximum === "number") {
    schema.maximum = schema.exclusiveMaximum;
    schema.exclusiveMaximum = true;
  }
  if (typeof schema.exclusiveMinimum === "number") {
    schema.minimum = schema.exclusiveMinimum;
    schema.exclusiveMinimum = true;
  }
  return schema;
}
var src_default = convert;
