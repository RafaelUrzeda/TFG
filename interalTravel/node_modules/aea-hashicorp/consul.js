const fs = require('fs');
const https = require('https');
const axios = require('axios');
const YAML = require('yaml');
const Ajv = require('ajv');
const { logger } = require('aea-logger');
const CronJob = require('cron').CronJob;
const schema = require('./schema');

const CONSUL_DISCOVERY_CRON = process.env['CONSUL_DISCOVERY_CRON'] || 15;
const CONSUL_KV_CRON = process.env['CONSUL_KV_CRON'] || 240;

let consulConfig;

let jobDiscovery;
let jobKV;

let httpsAgent;
let watcher;
let modifyIndexKV;
let discoveredServices = [];

let replacer = (key, value) => {
    if (typeof value === 'string' && value.length > 100) {
        return '...';
    }
    return value;
}

let mergeJson = (o, objectData) => {
    if (typeof o === 'object') {
        for (let key in o) {
            if (objectData[key] === undefined) {
                objectData[key] = o[key];
                logger.info('   |--> [Load KV] ' + key + ':' + JSON.stringify(objectData[key], replacer));
            } else {
                if ((typeof o[key] !== 'object') && (o[key] !== objectData[key])) {
                    objectData[key] = o[key];
                    logger.info('   |--> [Load KV] ' + key + ':' + JSON.stringify(objectData[key]), replacer);
                }
                mergeJson(o[key], objectData[key]);
            }
        }
    }
};

let consulKVHTTPS = async (objectData) => {
    let optionsConsulKV = {
        url: getConsulKVURL(),
        method: 'GET',
        httpsAgent: httpsAgent,
        headers: 'CONSUL_HTTP_TOKEN' in process.env ? { "X-Consul-Token": process.env.CONSUL_HTTP_TOKEN } : {}
    };

    try {
        let resp = await axios.request(optionsConsulKV);

        if (resp.status === 200) {
            if (resp.data !== undefined && resp.data[0]['ModifyIndex'] !== modifyIndexKV) {
                let base64 = resp.data[0]['Value'];
                let key = Buffer.from(base64, 'base64').toString();
                let json = YAML.parse(key);

                mergeJson(json, objectData);

                modifyIndexKV = resp.data[0]['ModifyIndex'];
            }
        } else {
            logger.error('aea-hashicorp Consul KVHTTPS - response.status = ' + resp.status);
            return [];
        }
    } catch (e) {
        logger.error('aea-hashicorp Consul KVHTTPS - ' + optionsConsulKV.url + ' - ' + e);
        return [];
    }
};

let consulServicesHTTPS = async (service) => {

    const optionsConsul = {
        url: process.env.CONSUL_URL + '/v1/health/service/' + service,
        method: 'GET',
        httpsAgent: httpsAgent,
        headers: 'CONSUL_HTTP_TOKEN' in process.env ? { "X-Consul-Token": process.env.CONSUL_HTTP_TOKEN } : {}
    };

    try {
        let resp = await axios.request(optionsConsul);
        if (resp.status === 200) {
            if (resp.data !== undefined) {
                return resp.data;
            }
        } else {
            logger.error('aea-hashicorp Consul ServicesHTTPS - response.status = ' + resp.status);
            return [];
        }
    } catch (e) {
        logger.error('aea-hashicorp Consul ServicesHTTPS - ' + optionsConsul.url + ' - ' + e);
        return [];
    }
};

let secToCron = (seconds) => {
    let hou = Math.trunc(seconds / 3600);
    if (hou !== 0) {
        return Math.floor(Math.random() * 59).toString() + ' ' + Math.floor(Math.random() * 59).toString() + ' */' + hou.toString() + ' * * *';
    }
    let min = Math.trunc(seconds / 60);
    if (min !== 0) {
        return Math.floor(Math.random() * 59).toString() + ' */' + min.toString() + ' * * * *';
    }
    let seg = seconds % 60;
    if (seg > 0) {
        let init = Math.floor(Math.random() * seg);
        let segs = init.toString();
        init += seg;
        while (init < 60) {
            segs += ',' + init.toString();
            init += seg;
        }
        return segs + ' * * * * *';
    }
    return '* * * * * *';
}

let validateConfig = (json) => {

    let ajv = new Ajv({ strict: false, allowUnionTypes: true });
    let validate = ajv.compile(schema);
    return { valid: validate(json), error: validate.errors }
}

/**
 * Carga en un objeto las KV (consul). URL = CONSUL_URL + '/v1/kv/' + NOMAD_DC + '/' + NOMAD_JOB_NAME + '.yml'
 * Inicia cron para: refrescar servicios y KV
 * ca: process.env.CONSUL_CA
 * cert: process.env.CONSUL_CLI
 * key: process.env.CONSUL_KEY
 * @param  {object} [objectData] - json de coniguración donde guardar las KV de consul
 * @param  {object} [config]- json de configuración. Ejemplo: {discovery: {kermit: 'sec-hydra-rest',loyalty: 'suma-loyalty-rest--v4'},kv: true}
 * @returns {Promise<void>}
 */
let init = async (objectData, config) => {

    if (typeof config !== "object" || typeof objectData !== "object") {
        throw new Error('aea-hashicorp Consul init - objectData/config does not an object');
    }

    consulConfig = Object.assign({}, config);
    let v = validateConfig(consulConfig);
    if (!v.valid) {
        throw new Error('aea-hashicorp Consul init - object config does not valid ' + JSON.stringify(v.error));
    }

    updateHttpsAgent(process.env.CONSUL_CA, process.env.CONSUL_CLI, process.env.CONSUL_KEY, true);

    if (consulConfig['kv']) {


        logger.info('aea-hashicorp Consul init - KV Properties API:' + getConsulKVURL());
        await consulKVHTTPS(objectData);

        const cronRangesKV = secToCron(CONSUL_KV_CRON);
        logger.info('   |--> [Auto Refresh Create Cron] ' + cronRangesKV);
        jobKV = new CronJob(cronRangesKV, function () {
            consulKVHTTPS(objectData);
        }, null, true, 'America/Los_Angeles', null, false);
    }

    if (consulConfig['discovery']) {

        logger.info('aea-hashicorp Consul init - ServiceDiscovery');
        const cronRangesSD = secToCron(CONSUL_DISCOVERY_CRON);
        logger.info('   |--> [services] ' + JSON.stringify(consulConfig['discovery']));
        logger.info('   |--> [Auto Refresh Create Cron] ' + cronRangesSD);
        jobDiscovery = new CronJob(cronRangesSD, function () {
            refreshServices(consulConfig['discovery']);
        }, null, true, 'America/Los_Angeles', null, false);

        await refreshServices(consulConfig['discovery']);
    }

    logger.info('aea-hashicorp Consul init - Config App' + JSON.stringify(objectData, replacer));
};

let refreshServices = async (refreshservices) => {

    let auxObj = [];
    for (let i in refreshservices) {
        let instances = await consulServicesHTTPS(refreshservices[i]);
        if (instances.length === 0) {
            logger.warn('aea-hashicorp Consul ServiceDiscovery - "' + refreshservices[i] + '" not found');
        }
        let s = {
            name: refreshservices[i],
            allocs: []
        }
        for (let a in instances) {
            const instance = instances[a];
            const checks = instance.Checks || [];
            const pass = checks.every(check => check.Status === "passing");

            if (!pass) {
                logger.warn('aea-hashicorp Consul ServiceDiscovery - Service "' + instance.Service.Service + '" not passed');
                continue;
            }
            s.allocs.push(instance.Service.Address + ':' + instance.Service.Port);

        }
        auxObj.push(s);
    }
    if (JSON.stringify(discoveredServices) !== JSON.stringify(auxObj)) {
        logger.info('aea-hashicorp Consul ServiceDiscovery - Update allocations... ' + JSON.stringify(auxObj) + ' [before: ' + JSON.stringify(discoveredServices) + ' ]');
        discoveredServices = auxObj;
    }
};

/**
 * retorna la dirección de la instancia del servicio indicado
 * @param {string} service - nombre del servicio a devolver
 * @returns {string|null}
 */
let getAllocation = (service) => {

    let s = discoveredServices.find(o => o.name === service);
    if (s === undefined) {
        logger.warn('aea-hashicorp Consul getAllocation - instance "' + service + '" not found');
        return 'http://null';
    }
    return 'http://' + s.allocs[Math.floor(Math.random() * (s.allocs.length))];
};

let stopJobDiscovery = () => {
    logger.info('aea-hashicorp Consul - stopJobDiscovery');
    return jobDiscovery.stop();
}

let stopJobKV = () => {
    logger.info('aea-hashicorp Consul - stopJobKV');
    return jobKV.stop();
}

let stopWatcher = () => {
    logger.info('aea-hashicorp Consul - stopJobKVstopWatcher');
    return watcher.stop();
}

/**
 * Genera y actualiza httpAgent si se modifican los certificados.  
 * @param {string} caPath - ruta de la ca en formato .pem
 * @param {string} cliPath - ruta del certificado en formato .pem
 * @param {string} cliKeyPath - ruta de la key del certificado en formato .pem
 * @param {boolean} watchChanges - especifica si se debe o no hacer un seguimiento de la carpeta.
 * @returns {null}
 */
let updateHttpsAgent = function (caPath, cliPath, cliKeyPath, watchChanges = false) {
    httpsAgent = buildHttpsAgent(caPath, cliPath, cliKeyPath);
    if (watchChanges) {
        logger.info(`aea-hashicorp updateHttpsAgent: Enabling watching file: ${cliPath}`);
        watcher = fs.watchFile(cliPath, (curr, prev) => {
            try {
                httpsAgent = buildHttpsAgent(caPath, cliPath, cliKeyPath);
                logger.info(`aea-hashicorp updateHttpsAgent: Certificate modified "${cliPath}" reloading httpsAgent`);
                logger.info(`aea-hashicorp updateHttpsAgent: Certificate modified. the current mtime is: ${curr.mtime}`);
                logger.info(`aea-hashicorp updateHttpsAgent: Certificate modified. the previous mtime was: ${prev.mtime}`);
            }
            catch (error) {
                logger.error(`aea-hashicorp updateHttpsAgent: Update failed --> "${error}"`);
            }
        });
    }
}

/**
 * Genera httpsAgent.  
 * @param {string} caPath - ruta de la ca en formato .pem
 * @param {string} cliPath - ruta del certificado en formato .pem
 * @param {string} cliKeyPath - ruta de la key del certificado en formato .pem
 * @returns {object|null} -- Retorna el objeto httpAgent
 */
let buildHttpsAgent = function (caPath, cliPath, cliKeyPath) {
    try {
        return new https.Agent({
            ca: fs.readFileSync(caPath),
            cert: fs.readFileSync(cliPath),
            key: fs.readFileSync(cliKeyPath)
        });
    } catch (e) {
        throw new Error('aea-hashicorp updateHttpsAgent - reading SSL certificate files: ca(file_path=' + caPath + ') cert(file_path=' + cliPath + ') key(file_path=' + cliKeyPath + '). Check the env vars: CONSUL_CA, CONSUL_CLI, CONSUL_KEY.  ' + e.stack);
    }
}

let getConsulKVURL = function () {
    return process.env.CONSUL_KV ? process.env.CONSUL_URL + process.env.CONSUL_KV : process.env.CONSUL_URL + '/v1/kv/' + process.env.NOMAD_DC + '/' + process.env.NOMAD_JOB_NAME + '.yml';
}

let getDiscoveredServices = function (service) {
    let s = discoveredServices.find(o => o.name === service).allocs;
    return s;
}


module.exports = { init, getAllocation, stopJobDiscovery, stopJobKV, stopWatcher, getDiscoveredServices };